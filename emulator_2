import tkinter as tk
import getpass, socket, shlex
import argparse, xml.etree.ElementTree as ET
import csv, datetime
from pathlib import Path

# --- Получаем имя пользователя и хост ---
user = getpass.getuser()
host = socket.gethostname()
prompt = f"{user}@{host}$ "

# --- Чтение параметров из командной строки ---
parser = argparse.ArgumentParser()
parser.add_argument("--vfs")
parser.add_argument("--log")
parser.add_argument("--script")
parser.add_argument("--config")
cli = parser.parse_args()

# --- Чтение конфигурационного XML-файла ---
cfg = {}
if cli.config:
    try:
        tree = ET.parse(cli.config)
        root = tree.getroot()
        cfg = {
            "vfs": root.findtext("vfs"),
            "log": root.findtext("log"),
            "script": root.findtext("script")
        }
    except Exception as e:
        print(f"[config] Ошибка чтения XML: {e}")

# --- Приоритет: CLI > XML ---
VFS_PATH = cli.vfs or cfg.get("vfs")
LOG_PATH = cli.log or cfg.get("log")
SCRIPT_PATH = cli.script or cfg.get("script")

# --- Логирование команд в CSV ---
def log_event(cmd, args, status):
    if not LOG_PATH:
        return
    try:
        file_exists = Path(LOG_PATH).exists()
        with open(LOG_PATH, "a", newline="", encoding="utf-8") as f:
            writer = csv.writer(f, delimiter=";")
            if not file_exists:
                writer.writerow(["timestamp", "user", "command", "args", "status"])
            writer.writerow([
                datetime.datetime.now().isoformat(timespec="seconds"),
                user,
                cmd,
                " ".join(args),
                status
            ])
    except Exception as e:
        print(f"[log] Ошибка записи: {e}")

# --- GUI ---
win = tk.Tk()
win.title(f"Эмулятор — [{user}@{host}]")
win.geometry("700x400")

# Поле вывода (только для чтения)
term = tk.Text(win, bg="black", fg="white", insertbackground="white", state="disabled")
term.pack(expand=True, fill="both")

# Поле ввода команд
entry = tk.Entry(win, bg="gray15", fg="white", insertbackground="white")
entry.pack(fill="x", ipady=0)
entry.focus()

# Начальный вывод
term.configure(state="normal")
term.insert("end", f"Эмулятор запущен. Введите команды: ls, cd, exit\nСессия: {user}@{host}\n\n")
term.insert("end",
    f"Параметры запуска:\n"
    f"VFS: {VFS_PATH}\n"
    f"Log: {LOG_PATH}\n"
    f"Script: {SCRIPT_PATH}\n"
    f"Config: {cli.config}\n\n"
)
term.insert("end", prompt)
term.configure(state="disabled")

# --- Выполнение команд ---
def execute(cmd, args):
    if cmd == "exit":
        log_event(cmd, args, "exit")
        win.destroy()
        return
    elif cmd == "ls":
        output = f"command: ls\nargs: {args}"
        status = "ok"
    elif cmd == "cd":
        output = f"command: cd\nargs: {args}\nnote: директория не меняется (заглушка)"
        status = "ok"
    else:
        output = f"{cmd}: command not found"
        status = "error"

    term.configure(state="normal")
    term.insert("end", f"\n{output}\n{prompt}")
    term.configure(state="disabled")
    term.see("end")

    log_event(cmd, args, status)

# --- Обработка ввода пользователя ---
def on_enter(event):
    cmdline = entry.get().strip()
    entry.delete(0, "end")

    if not cmdline:
        return

    try:
        parts = shlex.split(cmdline)
    except Exception as e:  # незакрытая кавычка
        term.configure(state="normal")
        term.insert("end", f"\nparse error: {e}\n{prompt}")
        term.configure(state="disabled")
        term.see("end")
        return

    cmd, args = parts[0], parts[1:]

    term.configure(state="normal")
    term.insert("end", f"\n{prompt}{cmdline}")
    term.configure(state="disabled")

    execute(cmd, args)

entry.bind("<Return>", on_enter)

# --- Выполнение стартового скрипта ---
def run_script(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            lines = f.readlines()
    except Exception as e:
        term.configure(state="normal")
        term.insert("end", f"\n[script] Ошибка чтения: {e}\n{prompt}")
        term.configure(state="disabled")
        return
    for raw in lines:
        line = raw.strip()
        if not line or line.startswith("#"):
            continue
        term.configure(state="normal")
        term.insert("end", f"\n{prompt}{line}")  # имитация пользователя
        term.configure(state="disabled")
        try:
            parts = shlex.split(line)
        except Exception as e:  # незакрытая кавычка
            term.configure(state="normal")
            term.insert("end", f"\n[script] parse error: {e}")
            term.configure(state="disabled")
            continue
        if not parts:
            continue
        cmd, args = parts[0], parts[1:]
        if cmd == "exit":
            log_event(cmd, args, "exit")
            win.after(0, win.destroy)
            return
        execute(cmd, args)

if SCRIPT_PATH:
    run_script(SCRIPT_PATH)  # запуск скрипта

win.mainloop()
